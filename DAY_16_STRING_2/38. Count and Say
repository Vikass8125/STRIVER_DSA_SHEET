The count-and-say sequence is a sequence of digit strings defined by the recursive formula:

countAndSay(1) = "1"
countAndSay(n) is the way you would "say" the digit string from countAndSay(n-1), which is then converted into a different digit string.
To determine how you "say" a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit.
Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.

For example, the saying and conversion for digit string "3322251":


Given a positive integer n, return the nth term of the count-and-say sequence.

 

Example 1:

Input: n = 1
Output: "1"
Explanation: This is the base case.
Example 2:

Input: n = 4
Output: "1211"
Explanation:
countAndSay(1) = "1"
countAndSay(2) = say "1" = one 1 = "11"
countAndSay(3) = say "11" = two 1's = "21"
countAndSay(4) = say "21" = one 2 + one 1 = "12" + "11" = "1211"
 

Constraints:

1 <= n <= 30

========================

Find the n’th term in Look-and-say (Or Count and Say) Sequence. The look-and-say sequence is the sequence of the below integers: 
1, 11, 21, 1211, 111221, 312211, 13112221, 1113213211, … 

How is the above sequence generated? 
n’th term is generated by reading (n-1)’th term.

The first term is "1"

Second term is "11", generated by reading first term as "One 1" 
(There is one 1 in previous term)

Third term is "21", generated by reading second term as "Two 1"

Fourth term is "1211", generated by reading third term as "One 2 One 1" 

and so on
How to find n’th term? 

Example: 

Input: n = 3
Output: 21

Input: n = 5
Output: 111221

======================================================================================================

MY_SOLUTION

The idea is simple, we generate all terms from 1 to n. First, two terms are initialized as “1” and “11”, and all other terms are generated using previous terms. 
To generate a term using the previous term, we scan the previous term. While scanning a term, we simply keep track of the count of all consecutive characters. 
For a sequence of the same characters, we append the count followed by the character to generate the next term.

Below is an implementation of the above idea.  


// Java program to find n'th
// term in look and say sequence
 
class GFG
{
 
    // Returns n'th term in
    // look-and-say sequence
    static String countnndSay(int n)
    {
    // Base cases
    if (n == 1)     return "1";
    if (n == 2)     return "11";
 
    // Find n'th term by generating
    // all terms from 3 to n-1.
    // Every term is generated
    // using previous term
     
    // Initialize previous term
    String str = "11";
    for (int i = 3; i <= n; i++)
    {
        // In below for loop, previous
        // character is processed in
        // current iteration. That is
        // why a dummy character is
        // added to make sure that loop
        // runs one extra iteration.
        str += '$';
        int len = str.length();
 
        int cnt = 1; // Initialize count
                     // of matching chars
        String tmp = ""; // Initialize i'th
                         // term in series
        char []arr = str.toCharArray();
         
        // Process previous term
        // to find the next term
        for (int j = 1; j < len; j++)
        {
            // If current character
            // doesn't match
            if (arr[j] != arr[j - 1])
            {
                // Append count of
                // str[j-1] to temp
                tmp += cnt + 0;
 
                // Append str[j-1]
                tmp += arr[j - 1];
 
                // Reset count
                cnt = 1;
            }
 
            // If matches, then increment
            // count of matching characters
            else cnt++;
        }
 
        // Update str
        str = tmp;
    }
 
    return str;
    }
     
    // Driver Code
    public static void main(String[] args)
    {
        int N = 3;
        System.out.println(countnndSay(N));
    }
}

====================================================================================================

Another Approach(Using STL): There is one more idea where we can use unordered_map from c++ stl to track the count of digits. 
Basic idea is to use a generator function that will generate a string from the previous string.
In the count and say function we will iterate over integers from 1 to n-1 and keep updating our result.


import java.io.*;
import java.util.*;
 
class GFG {
  // generator function returns int string from prev int
  // string e.g. -> it will return '1211' for '21' ( One 2's
  // and One 1)
  static String generator(String str)
  {
    String ans = "";
 
    HashMap<Character, Integer>tempCount = new HashMap<>(); // It is used to count integer sequence
 
    for (int i = 0; i < str.length() + 1; i++) {
      // when current char is different from prev one we
      // clear the map and update the ans
      if (i == str.length()  || tempCount.containsKey(str.charAt(i)) == false && i > 0) {
        ans += String.valueOf(tempCount.get(str.charAt(i-1))) + str.charAt(i-1);
        tempCount.clear();
      }
      // when current char is same as prev one we increase
      // it's count value
 
      if(i == str.length()){
        tempCount.put(null, 1);
      }
      else{
        if(tempCount.containsKey(str.charAt(i))){
          tempCount.put(str.charAt(i), tempCount.get(str.charAt(i))+1);
        }
        else{
          if(i != str.length())tempCount.put(str.charAt(i), 1);
        }
      }
    }
    return ans;
  }
 
  static String countnndSay(int n)
  {
    String res = "1"; // res variable keep tracks of string
    // from 1 to n-1
 
    // For loop iterates for n-1 time and generate strings
    // in sequence "1" -> "11" -> "21" -> "1211"
    for (int i = 1; i < n; i++) {
      res = generator(res);
    }
 
    return res;
  }
 
  // Driver Code
  public static void main(String args[])
  {
    int N = 3;
    System.out.println(countnndSay(N));
  }
}


=============================================================================

Simulation
The best way to solve this problem is to simulate it.
We will start our simulation with the single S. S will store the current sequence. At first, the S will be equal to “1”.
Then we will repeat the following steps for N-1 iterations.
Declare a temporary string Temp with an empty string. We will use Temp to store consecutively similar digits.
We will declare an array Count. We will store the count of the consecutively similar digits in count.
Now we will iterate through string S to build Temp and count.
 Let's say we are position i, we will count the consecutive frequency of S[i], and to do so we will keep on increasing the count of S[i] until all 
 the digits are same, and once we get a new digit we will insert this digit in temp and initialize its count with one and will continue the same process.
For example, if we have string “1121”, then at the start we will insert ‘1’ into temp and initialize its count to 1 and as then we will move further 
again when we encounter a consecutive ‘1’ we will increment the counter to 2, and when we encounter ‘2’ in the string we will insert this into temp 
so temp becomes “12” and we will initialize its count to 1.
Now when we encounter 1 again it will be treated as a new character because the previous character was ‘2’ so we will insert this into temp and
initialize its count to ‘1’, so finally, after complete traversal temp will be “121”, and count array will be [2,1,1],
We will append S[i] to Temp and store count of consecutive digits starting from i in Count
Now we have to build the sequence for the next iteration.
To do this we reset S with an empty string and iterate the Temp and Count array.
If we are currently at the ith index then add Count[i] to S and then add Temp[i] to S.
For example, we are having the sequence S as “1211” and we want to find a sequence for the next iteration then we will first traverse S and make 
the Temp and Count array which will look like this.
Temp[1] = 1 , Count[1] = 1
Temp[2] = 2 , Count[2] = 1
Temp[3] = 1 , Count[3] = 2
So the new sequence will be “111221”
Time Complexity
O(2 ^ N), where N is the number of iterations.

 

After each iteration, the size of the sequence is becoming approximately double.

Space Complexity
O(M), M is the size of the final sequence. 

 

Because we are storing the count of the digit in the count array and the digits in the Temp string.


/*
    Time Complexity: O(2 ^ N)
    Space Complexity: O(M),

    where N is the number of iterations and M is the length of the final string.
*/

import java.util.ArrayList;

public class Solution 
{

    public static String writeAsYouSpeak(int n) 
    {

        // We initialize our starting string s with "1".
        String s = "1";
        
        // We initialize the iterations with n-1.
        int iterations = n - 1;
        while (iterations-- > 0) 
        {
            // We will initialize temp with an empty string and we initialize count.
            String temp = "";
            ArrayList<Integer> count = new ArrayList<Integer>();
            
            // currentIndex will store the current position in string s, currentChar will store the current character that we will match with consecutive characters.
            // And currentCount will store the count of that character.
            int currentIndex = 0;
            
            // Now we will iterate through s and we will try to make temp and count.
            while (currentIndex < s.length()) 
            {
                char currentChar = s.charAt(currentIndex);
                int currentCount = 0;
                while ((currentIndex < s.length()) && (s.charAt(currentIndex) == currentChar)) 
                {
                    currentCount++;
                    currentIndex++;
                }

                temp += currentChar;
                count.add(currentCount);
            }

            // Now we will make string s for the next iteration.
            // We will add count[i] and temp[i] to s for each position of count.
            s = "";
            for (int i = 0; i < count.size(); i++) 
            {
                s += (char)('0' + count.get(i));
                s += temp.charAt(i);
            }
        }
        return s;
    }

}

=======================================

public class Solution {
    public String countAndSay(int n) {
        String s = "1";
        for(int i = 1; i < n; i++){
            s = countIdx(s);
        }
        return s;
    }
    
    public String countIdx(String s){
        StringBuilder sb = new StringBuilder();
        char c = s.charAt(0);
        int count = 1;
        for(int i = 1; i < s.length(); i++){
            if(s.charAt(i) == c){
                count++;
            }
            else
            {
                sb.append(count);
                sb.append(c);
                c = s.charAt(i);
                count = 1;
            }
        }
        sb.append(count);
        sb.append(c);
        return sb.toString();
    }
}

===============================
public class Solution {
    public String countAndSay(int n) {
	    	StringBuilder curr=new StringBuilder("1");
	    	StringBuilder prev;
	    	int count;
	    	char say;
	        for (int i=1;i<n;i++){
	        	prev=curr;
	 	        curr=new StringBuilder();       
	 	        count=1;
	 	        say=prev.charAt(0);
	 	        
	 	        for (int j=1,len=prev.length();j<len;j++){
	 	        	if (prev.charAt(j)!=say){
	 	        		curr.append(count).append(say);
	 	        		count=1;
	 	        		say=prev.charAt(j);
	 	        	}
	 	        	else count++;
	 	        }
	 	        curr.append(count).append(say);
	        }	       	        
	        return curr.toString();
        
    }
}

=================================
// for the nth number, you just need to count characters of the (n-1)th number,
// for the (n-1)th number, you just need to count characters of  the (n-2)th number,
// ...

public String countAndSay(int n) {
	if(n == 1) return "1";

	StringBuilder res = new StringBuilder();

	// recursively call for (n-1) th number, "0" is only for the edge case at the end of the loop with `s.charAt(i+1)`
	String s = countAndSay(n-1) + "0"; 

	for(int i=0, c=1; i < s.length()-1; i++, c++){
		// if next digit is different, then append the count so far `c` and the digit itself, then set count `c` to zero
		if(s.charAt(i+1) != s.charAt(i)){
			res.append(c).append(s.charAt(i));
			c = 0;  
		}
	}

	return res.toString();
}
=================================
public String countAndSay(int n) {
if(n == 1) return "1";

StringBuilder res = new StringBuilder();

// recursively call for (n-1) th number, "0" is only for the edge case at the end of the loop with `s.charAt(i+1)`
String s = countAndSay(n-1); 

for(int i=0, c=1; i < s.length(); i++, c++){
	// if next digit is different, then append the count so far `c` and the digit itself, then set count `c` to zero
	//Added condition to see if it's the last character to terminate and count the freq so far
             if(i==s.length()-1 || s.charAt(i+1) != s.charAt(i)){
		res.append(c).append(s.charAt(i));
		c = 0;  
	}
}

return res.toString();
}

==========================
/**
 * Find each state starting from 1st to nth.
 * 
 * Time Complexity: O(L(1) + L(2) + L(3) + ... + L(N-1) + L(N))
 *
 * Space Complexity: O(L(N-1) + L(N))
 *
 * N = Input number. L(N) = Length of Nth state
 */
class Solution {
    public String countAndSay(int n) {
        if (n <= 0) {
            throw new IllegalArgumentException("Invalid input");
        }

        StringBuilder sb = new StringBuilder("1");
        for (int i = 2; i <= n; i++) {
            sb = getNextState(sb);
        }
        return sb.toString();
    }

    private StringBuilder getNextState(StringBuilder curSb) {
        StringBuilder nextSb = new StringBuilder();
        int len = curSb.length();
        int i = 0;
		
        while (i < len) {
            char c = curSb.charAt(i++);
            int count = 1;
            while (i < len && c == curSb.charAt(i)) {
                count++;
                i++;
            }
            nextSb.append(count).append(c);
        }
		
        return nextSb;
    }
}

===================================
class Solution {

	public String countAndSay(int n){ 
		if(n == 1) return "1";  //if n==1 simply return "1"
		
		String s = countAndSay(n-1);  // else make recursive calls until n==1
		
		StringBuilder str = new StringBuilder(); // create string builder or string buffer object for easy mutations
		
		int count = 1 , i = 0; // count of every character is atleast 1 so take count as 1
		
		while(i < s.length()){ // main loop
		
			char ch = s.charAt(i++); // store charcter at i and increment i
			
			while(i < s.length() && s.charAt(i) == ch){ // create a loop to count the number of adjacent characters in string
				i++;    count++;
			}
			
			str.append(count).append(ch); // add count and current character to str
			count = 1; // reset count to 1
		}
		
	return str.toString(); // return str as string
}
}

===================================
Since the function itself accepting an integer and return a String, internally we can call this function with n-1 recursively. 
Therefore, no extra function is required. Also we just need to keep a counter to track how many times a character appears without adding a variable
to track 'previous char'

public String countAndSay(int n) {
    if (n == 1) {
        return "1";
    }

    String prevStr = countAndSay(n - 1);

    StringBuffer sb = new StringBuffer();

    int count = 0;
    int ptr = 0;
    while (ptr < prevStr.length()) {
        count++;

        char curChar = prevStr.charAt(ptr);
        if (ptr + 1 >= prevStr.length() || curChar != prevStr.charAt(ptr + 1)) {
            sb.append(count).append(curChar);

            count = 0;
        }

        ptr++;
    }

    return sb.toString();
}

=================================
public class Solution {
    public String countAndSay(int n) {
        String s = "1";
        for (int i = 1; i < n; i++) {
            StringBuilder sb = new StringBuilder();
            for (int j = 1, count = 1; j <= s.length(); j++) {
                if (j == s.length() || s.charAt(j - 1) != s.charAt(j)) {
                    sb.append(count);
                    sb.append(s.charAt(j - 1));
                    count = 1;
                } else count++;
            }
            s = sb.toString();
        }
        return s;
    }
}
=================================


lass Solution {
    public String countAndSay(int n) {
        String s = "";
         switch (n) {
            case 1: s = "1"; break;
            case 2: s = "11"; break;
            case 3: s = "21"; break;
            case 4: s = "1211"; break;
            case 5: s = "111221"; break;
            case 6: s = "312211"; break;
            case 7: s = "13112221"; break;
            case 8: s = "1113213211"; break;
            case 9: s = "31131211131221"; break;
            case 10: s = "13211311123113112211"; break;
            case 11: s = "11131221133112132113212221"; break;
            case 12: s = "3113112221232112111312211312113211"; break;
            case 13: s = "1321132132111213122112311311222113111221131221"; break;
            case 14: s = "11131221131211131231121113112221121321132132211331222113112211"; break;
            case 15: s = "311311222113111231131112132112311321322112111312211312111322212311322113212221"; break;
            case 16: s = "132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211"; break;
            case 17: s = "11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221"; break;
            case 18: s = "31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211"; break;
            case 19: s = "1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221"; break;
            case 20: s = "11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211"; break;
            case 21: s = "311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221"; break;
            case 22: s = "132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211"; break;
            case 23: s = "111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221"; break;
            case 24: s = "3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211"; break;
            case 25: s = "132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221"; break;
            case 26: s = "1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211"; break;
            case 27: s = "31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221"; break;
            case 28: s = "13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211"; break;
            case 29: s = "11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221"; break;
            case 30: s = "3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211"; break;
            default: break;
         }
        return s;
    }
}
By the way, I got the numbers by making a different (less God-like) solution first. Just in case anyone thought I cheated wholesale; here it is:

class Solution {
    public String countAndSay(int n) {
        String s = "";
         switch (n) {
            case 1: s = "1"; break;
            case 2: s = "11"; break;
            case 3: s = "21"; break;
            case 4: s = "1211"; break;
            case 5: s = "111221"; break;
            case 6: s = "312211"; break;
            case 7: s = "13112221"; break;
            case 8: s = "1113213211"; break;
            case 9: s = "31131211131221"; break;
            case 10: s = "13211311123113112211"; break;
            default: break;
         }
        
        if (n > 10) {
            s = "13211311123113112211";
            String ans;
            for (int i = 10; i < n; i++) {
               ans = "";
               int count = 0;
               char num = s.charAt(0);
               for (int j = 0; j < s.length(); ++j) {
                  char thisNum = s.charAt(j);
                  if (thisNum == num) {
                     count++;
                  }
                  else {
                     ans += count; ans += num;
                     num = thisNum;
                     count = 1;
                  }

                  if (j == s.length() - 1) {
                     ans += count; ans += num;
                  }
               }
               s = ans;
            }
         }
        return s;
    }
}
